## <font color='red'> 1.1 K8s Cluster </font>
Lab demonstrates a possible GitOps workflow using Argo CD and Tekton. We are using Argo CD to setup our Kubernetes clusters dev and prod (in the following we will only use the dev cluster) and Tekton to build and update our example application.

In this lab we're going to:
* install Dev minikube cluster
* install ArgoCD minikube cluster
* configure to pull image from Docker Hub
* configure to pull app from GitHub
* sync app on K8s-dev cluster

---

#### <font color='red'>IMPORTANT:</font> 
<strong>Please ensure you start with a clean environment. 
If you have previously run minikube, you will need to delete the existing instance.</strong>

to stop  minikube:
```
minikube stop
```
to delete  minikube:
```
minikube delete
```

---

Pre-requisties:
* GitOps is a way to do Kubernetes cluster management and application delivery.  It works by using Git as a single source of truth for declarative infrastructure and applications. With GitOps, the use of software agents can alert on any divergence between Git with what's running in a cluster, and if there's a difference, Kubernetes reconcilers automatically update or rollback the cluster depending on the case. With Git at the center of your delivery pipelines, developers use familiar tools to make pull requests to accelerate and simplify both application deployments and operations tasks to Kubernetes.

you will require a GitHub account.

* Docker Hub


---

#### <font color='red'>1.1.1  Install Dev & ArgoCD K8s Clusters </font>
The next step is to create two Kubernetes clusters: 
* k8s-dev - push your application and run it
* k8s-argocd - install ArgoCD

start k8s-dev cluster:
```
minikube start -p k8s-dev
```
minikube k8s-dev tunnel:
```
minikube -p k8s-dev tunnel
```
start k8s-argocd cluster:
```
minikube start -p k8s-argocd
```
minikube k8s-argocd tunnel:
```
minikube -p k8s-argocd tunnel
```
confirm that your k8s-argocd context is set correctly:
```
kubectl config use-context argocd-k8s
```

---

## <font color='red'> 1.2 ArgoCD </font>
ArgoCD is a declarative GitOps tool built to deploy applications to Kubernetes. While the continuous delivery (CD) space is seen by some as crowded these days, ArgoCD does bring some interesting capabilities to the table.

Unlike other tools, ArgoCD is lightweight and easy to configure. It is purpose-built to deploy applications to Kubernetes so it doesn’t have the UI overhead of many tools built to deploy to multiple locations.

In this lab we're going to:
* install ArgoCD
* install ArgoCD CLI

#### <font color='red'>1.2.1  Install ArgoCD </font>
create namespace argocd:
```
kubectl create namespace argocd
```
install ArgoCD:
```
kubectl apply -n argocd -f 01_install-argocd.yaml
```
verfiy ArgoCD:
```
kubectl get pods -n argocd
```
Note: This will take a few minutes..
port-forward to expose service on localhost:8080:
```
kubectl port-forward svc/argocd-server -n argocd 8080:443
```
or chnage argocd-server service type to LoadBalancer:
```
kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "LoadBalancer"}}'
```

  > browse to ArgoCD:  http://localhost:8080

user: admin

initial password is autogenerated:
```
kubectl get pods -n argocd -l app.kubernetes.io/name=argocd-server -o name | cut -d'/' -f 2
```
Note: In the UI of Argo CD we can now see all deployed applications.

---

#### <font color='red'>1.2.2 Install ArgoCD CLI </font>

go to the releases site on GitHub:

  > https://github.com/argoproj/argo-cd/releases

select the correct version (currently Tags:1.8.7):

rename the file and move to $PATH:
```
cd Downloads
mv argocd-linux-amd64 argocd 
sudo mv argocd /usr/local/bin
```
log into ArgoCD:
```
argocd login localhost:8080
```
or
  > http://localhost:8080

if you want to change the password:
```
argocd account update-password
```
tell ArgoCD about your deployment target:
```
argocd cluster add k8s-dev
```
Note: This will add an ArgoCD service account onto the cluster.

---

#### <font color='red'>1.2.3 Build Demo Application </font>

---

#### <font color='red'>1.2.4 Add Demo Application to ArgoCD</font>

set up a couple of environment variables:
```
export ARGOCD_OPTS='--port-forward-namespace argocd'
```
Note: This variable will tell the argocd CLI client where our ArgoCD installation resides
set minikube dev ip:
```
export MINIKUBE_IP=https://$(minikube ip -p k8s-dev):8443
```
Note: This variable sets target cluster API URL.
create the application record:
```
argocd app create spring-petclinic --repo https://github.com/jporeilly/ArgoCD-demo.git --path . --dest-server $MINIKUBE_IP --dest-namespace default
```
verify status and configuration of your app:
```
argocd app list
```
Notice: the STATUS: OutOfSync and HEALTH: Missing. That’s because ArgoCD creates applications with manual triggers by default.  

“Sync” is the terminology ArgoCD uses to describe the application on your target cluster as being up to date with the sources ArgoCD is pulling from. You have set up ArgoCD to monitor the GitHub repository with the configuration files as well as the spring-petclinic container image in Docker Hub. Once the initial sync is completed, a change to either of these sources will cause the status in ArgoCD to change to OutOfSync.

more detailed view of your application configuration:
```
argocd app get spring-petclinic
```
ready to sync your application to your target cluster:
```
argocd app sync spring-petclinic
```
change kubectl contexts to your target cluster:
```
kubectl config use-context k8s-dev
```
port-forward to expose app on localhost:9090:
```
kubectl port-forward svc/spring-petclinic -n default 9090:8080
```










