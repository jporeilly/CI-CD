## <font color='red'> 2.3 GitHub Actions </font>
GitHub Actions help you automate tasks within your software development life cycle. GitHub Actions are event-driven, meaning that you can run a series of commands after a specified event has occurred. For example, every time someone creates a pull request for a repository, you can automatically run a command that executes a software testing script.

  > For further information: https://docs.github.com/en/actions

In this lab we're going to:
* create a simple GitHub action
* enable Ingress controller


---

#### <font color='red'>IMPORTANT:</font> 
<strong>Please ensure you start with a clean environment. 
If you have previously run minikube, you will need to delete the existing instance.</strong>

to stop  minikube:
```
minikube stop
```
to delete  minikube:
```
minikube delete
```

start minikube:
```
minikube start
```
minikube tunnel:
```
minikube tunnel
```


**Pre-requisties:**
If you want to try these GitHub actions you will require a GitHub account.

* Docker Hub


---

#### <font color='red'>2.3.1 nstall Dev minikube Cluster + Ingress </font>
You can set up continuous integration for your project using a workflow template that matches the language and tooling you want to use.


start minikube:
```
minikube start --driver=docker --cpus=4 --memory=8192m --profile=dev
```
start tunnel:
```
minikube tunnel
```
enable nginx controller:
```
minikube addons enable ingress --profile=dev
```
add our Ingresses to the /etc/hosts file:
```
sudo echo "`minikube ip --profile=dev` argocd-dev.fake grafana-dev.fake prometheus-dev.fake tekton-dev.fake server-dev.fake" | sudo tee -a /etc/hosts
```


#### <font color='red'>1.1.2  Install ArgoCD </font>

install ArgoCD:
```
kustomize build clusters/argocd/dev | k apply -f -
```
Note: this will take a few minutes...

verfiy ArgoCD:
```
kubectl get pods -n argocd
```
To deploy our manifests to the cluster we are using the app of apps pattern. For that we have to create a new Application, which manages all other applications (including Argo CD):
```
kubectl apply -f clusters/apps/dev.yaml
```

browse to ArgoCD > http://argocd-dev.fake

user: admin

initial password is autogenerated:
```
kubectl get pods -n argocd -l app.kubernetes.io/name=argocd-server -o name | cut -d'/' -f 2
```
Note: In the UI of Argo CD we can now see all deployed applications:

---

#### <font color='red'>1.1.3 Monitoring </font>
* Deploys the Prometheus Stack via the kube-prometheus-stack Helm chart.

* Prometheus is available at prometheus-dev.fake and Grafana at grafana-dev.fake

log into Prometheus:

 > http://prometheus-dev.fake

log into Grafana:

 > http://grafana-dev.fake

 user: admin
 password: admin

 import the example Dashboard for Argo CD:
```
 https://github.com/argoproj/argo-cd/blob/master/examples/dashboard.json
```

---

#### <font color='red'>1.1.4  Install Tekton </font>
We are using Tekton Pipelines to build our example application and to update the deployed Docker image. The required tasks and pipelines are deployed by Argo CD, but we have to manually provide the credentials for Docker Hub and GitHub. 

create the secrets:

kubectl create secret docker-registry docker-registry-secret --docker-server="https://index.docker.io/v1/" --docker-username=<DOCKER_USERNAME> --docker-password=<DOCKER_PASSWORD>
kubectl annotate secret docker-registry-secret tekton.dev/docker-0=https://index.docker.io/v1/
kubectl create secret generic github-secret --type="kubernetes.io/basic-auth" --from-literal=username=<GITHUB_USERNAME> --from-literal=password=<GITHUB_PASSWORD>
kubectl annotate secret github-secret tekton.dev/git-0=https://github.com